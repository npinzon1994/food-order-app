{"ast":null,"code":"var _jsxFileName = \"C:\\\\workspace\\\\react_practice\\\\udemy-projects-again\\\\food-order-app\\\\src\\\\context\\\\CartProvider.js\",\n  _s = $RefreshSig$();\nimport { useReducer } from \"react\";\nimport CartContext from \"./cart-context\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst defaultCartState = {\n  items: [],\n  totalPrice: 0\n};\nconst cartReducer = (state, action) => {\n  if (action.type === \"ADD\") {\n    //taking price of current item * its quantity and adding to totalPrice\n    const updatedTotalPrice = state.totalPrice + action.item.price * action.item.quantity;\n\n    //Now we need the logic for if an item already exists in our array\n\n    const existingCartItemIndex = state.items.findIndex(\n    //returns the index of the item (if it exists) in the array\n    item => item.id === action.item.id);\n    const existingCartItem = state.items[existingCartItemIndex]; //now we get the current item we need in the items[] array\n\n    let updatedItems;\n    if (existingCartItem) {\n      //if existingCartItem is a thing...\n      const updatedItem = {\n        ...existingCartItem,\n        //copy over data from cart item we found in items[] array\n        quantity: existingCartItem.quantity + action.item.quantity //update its quantity by adding the quantity of the new item to its existing quantity\n      };\n\n      updatedItems = [...state.items]; //copying over all previous items to new array (to keep it immutable)\n      updatedItems[existingCartItemIndex] = updatedItem; //replacing the old item with our updated item (with updated quantity)\n    } else {\n      //concat() returns a new array with the argument appended to the end\n      updatedItems = state.items.concat(action.item);\n    }\n    return {\n      items: updatedItems,\n      totalPrice: updatedTotalPrice\n    };\n  }\n  if (action.type === \"REMOVE\") {\n    //get index of item we're looking for\n    const existingCartItemIndex = state.items.findIndex(item => item.id === action.id);\n\n    //need current item to check its quantity\n    const existingCartItem = state.items[existingCartItemIndex];\n\n    //update total price\n    const updatedTotalPrice = state.totalPrice - existingCartItem.price;\n\n    //copy over items into temp array since items in array will change\n    let updatedItems;\n    if (existingCartItem.quantity === 1) {\n      //filters out items that aren't equal to current item's id\n      updatedItems = state.items.filter(item => item.id !== action.id);\n    } else {\n      const updatedItem = {\n        ...existingCartItem,\n        quantity: existingCartItem.quantity - 1\n      };\n      updatedItems = [...state.items];\n      updatedItems[existingCartItemIndex] = updatedItem;\n    }\n    return {\n      items: updatedItems,\n      totalPrice: updatedTotalPrice\n    };\n  }\n  if (action.type === \"CLEAR\") {\n    return defaultCartState;\n  }\n  return defaultCartState;\n};\nconst CartProvider = props => {\n  _s();\n  //this provides the concrete context object we'll be working with\n\n  /*\r\n    This is where useReducer goes. The action.type will check\r\n    if the current item we're adding is aready in the cart or\r\n    not. If no, we add the item to our items array. If yes, then\r\n    we just update that item's quantity.\r\n    */\n  const [cartState, dispatchCartAction] = useReducer(cartReducer, defaultCartState);\n  const addItemToCartHandler = item => {\n    dispatchCartAction({\n      type: \"ADD\",\n      item: item\n    });\n  };\n  const removeItemFromCartHandler = id => {\n    dispatchCartAction({\n      type: \"REMOVE\",\n      id: id\n    });\n  };\n  const clearItemsFromCartHandler = emptyArray => {\n    dispatchCartAction({\n      type: \"CLEAR\"\n    });\n  };\n  const cartContext = {\n    items: cartState.items,\n    totalPrice: cartState.totalPrice,\n    addItem: addItemToCartHandler,\n    removeItem: removeItemFromCartHandler,\n    clearCart: clearItemsFromCartHandler\n  };\n  return /*#__PURE__*/_jsxDEV(CartContext.Provider, {\n    value: cartContext,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 113,\n    columnNumber: 5\n  }, this);\n};\n_s(CartProvider, \"PxEugEseoIJIbjFwtAJal5z5ClY=\");\n_c = CartProvider;\nexport default CartProvider;\nvar _c;\n$RefreshReg$(_c, \"CartProvider\");","map":{"version":3,"names":["useReducer","CartContext","defaultCartState","items","totalPrice","cartReducer","state","action","type","updatedTotalPrice","item","price","quantity","existingCartItemIndex","findIndex","id","existingCartItem","updatedItems","updatedItem","concat","filter","CartProvider","props","cartState","dispatchCartAction","addItemToCartHandler","removeItemFromCartHandler","clearItemsFromCartHandler","emptyArray","cartContext","addItem","removeItem","clearCart","children"],"sources":["C:/workspace/react_practice/udemy-projects-again/food-order-app/src/context/CartProvider.js"],"sourcesContent":["import { useReducer } from \"react\";\r\nimport CartContext from \"./cart-context\";\r\n\r\nconst defaultCartState = {\r\n  items: [],\r\n  totalPrice: 0,\r\n};\r\n\r\nconst cartReducer = (state, action) => {\r\n  if (action.type === \"ADD\") {\r\n    //taking price of current item * its quantity and adding to totalPrice\r\n    const updatedTotalPrice =\r\n      state.totalPrice + action.item.price * action.item.quantity;\r\n\r\n    //Now we need the logic for if an item already exists in our array\r\n\r\n    const existingCartItemIndex = state.items.findIndex(\r\n      //returns the index of the item (if it exists) in the array\r\n      (item) => item.id === action.item.id\r\n    );\r\n\r\n    const existingCartItem = state.items[existingCartItemIndex]; //now we get the current item we need in the items[] array\r\n\r\n    let updatedItems;\r\n\r\n    if (existingCartItem) {\r\n      //if existingCartItem is a thing...\r\n      const updatedItem = {\r\n        ...existingCartItem, //copy over data from cart item we found in items[] array\r\n        quantity: existingCartItem.quantity + action.item.quantity, //update its quantity by adding the quantity of the new item to its existing quantity\r\n      };\r\n      updatedItems = [...state.items]; //copying over all previous items to new array (to keep it immutable)\r\n      updatedItems[existingCartItemIndex] = updatedItem; //replacing the old item with our updated item (with updated quantity)\r\n    } else {\r\n      //concat() returns a new array with the argument appended to the end\r\n      updatedItems = state.items.concat(action.item);\r\n    }\r\n\r\n    return { items: updatedItems, totalPrice: updatedTotalPrice };\r\n  }\r\n\r\n  if (action.type === \"REMOVE\") {\r\n    //get index of item we're looking for\r\n    const existingCartItemIndex = state.items.findIndex(\r\n      (item) => item.id === action.id\r\n    );\r\n\r\n    //need current item to check its quantity\r\n    const existingCartItem = state.items[existingCartItemIndex];\r\n\r\n    //update total price\r\n    const updatedTotalPrice = state.totalPrice - existingCartItem.price;\r\n\r\n    //copy over items into temp array since items in array will change\r\n    let updatedItems;\r\n\r\n    if (existingCartItem.quantity === 1) {\r\n      //filters out items that aren't equal to current item's id\r\n      updatedItems = state.items.filter((item) => item.id !== action.id);\r\n    } else {\r\n      const updatedItem = {\r\n        ...existingCartItem,\r\n        quantity: existingCartItem.quantity - 1,\r\n      };\r\n      updatedItems = [...state.items];\r\n      updatedItems[existingCartItemIndex] = updatedItem;\r\n    }\r\n    return { items: updatedItems, totalPrice: updatedTotalPrice };\r\n  }\r\n\r\n  if(action.type === \"CLEAR\"){\r\n    return defaultCartState;\r\n  }\r\n\r\n  return defaultCartState;\r\n};\r\n\r\nconst CartProvider = (props) => {\r\n  //this provides the concrete context object we'll be working with\r\n\r\n  /*\r\n    This is where useReducer goes. The action.type will check\r\n    if the current item we're adding is aready in the cart or\r\n    not. If no, we add the item to our items array. If yes, then\r\n    we just update that item's quantity.\r\n    */\r\n  const [cartState, dispatchCartAction] = useReducer(\r\n    cartReducer,\r\n    defaultCartState\r\n  );\r\n\r\n  const addItemToCartHandler = (item) => {\r\n    dispatchCartAction({ type: \"ADD\", item: item });\r\n  };\r\n\r\n  const removeItemFromCartHandler = (id) => {\r\n    dispatchCartAction({ type: \"REMOVE\", id: id });\r\n  };\r\n\r\n  const clearItemsFromCartHandler = (emptyArray) => {\r\n    dispatchCartAction({type: \"CLEAR\"})\r\n  }\r\n\r\n  const cartContext = {\r\n    items: cartState.items,\r\n    totalPrice: cartState.totalPrice,\r\n    addItem: addItemToCartHandler,\r\n    removeItem: removeItemFromCartHandler,\r\n    clearCart: clearItemsFromCartHandler\r\n  };\r\n\r\n  return (\r\n    <CartContext.Provider value={cartContext}>\r\n      {props.children}\r\n    </CartContext.Provider>\r\n  );\r\n};\r\n\r\nexport default CartProvider;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}